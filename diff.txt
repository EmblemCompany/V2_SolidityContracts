diff --git a/diff.txt b/diff.txt
index 51a82b2..e69de29 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,439 +0,0 @@
-diff --git a/foundry.toml b/foundry.toml
-index 25b918f..1bb6ecb 100644
---- a/foundry.toml
-+++ b/foundry.toml
-@@ -2,5 +2,14 @@
- src = "src"
- out = "out"
- libs = ["lib"]
-+via_ir = true
-+optimizer = true
-+optimizer_runs = 200
- 
--# See more config options https://github.com/foundry-rs/foundry/blob/master/crates/config/README.md#all-options
-+[rpc_endpoints]
-+localhost = "http://localhost:8545"
-+
-+[etherscan]
-+mainnet = { key = "${ETHERSCAN_API_KEY}" }
-+
-+# See more config options https://github.com/foundry-rs/foundry/tree/master/config
-diff --git a/lib/openzeppelin-contracts b/lib/openzeppelin-contracts
-index 0643d17..69c8def 160000
---- a/lib/openzeppelin-contracts
-+++ b/lib/openzeppelin-contracts
-@@ -1 +1 @@
--Subproject commit 0643d17e8d9640df803c5d256c53d458c4c6008d
-+Subproject commit 69c8def5f222ff96f2b5beff05dfba996368aa79
-diff --git a/script/DeployDiamond.s.sol b/script/DeployDiamond.s.sol
-index a4f7303..cf7f49e 100644
---- a/script/DeployDiamond.s.sol
-+++ b/script/DeployDiamond.s.sol
-@@ -2,12 +2,16 @@
- pragma solidity ^0.8.19;
- 
- import "forge-std/Script.sol";
--import "../src/Diamond.sol";
--import "../src/facets/DiamondCutFacet.sol";
--import "../src/facets/DiamondLoupeFacet.sol";
--import "../src/facets/OwnershipFacet.sol";
--import "../src/facets/VaultFacet.sol";
--import "../src/interfaces/IDiamondCut.sol";
-+import {Diamond} from "../src/Diamond.sol";
-+import {IDiamondCut} from "../src/interfaces/IDiamondCut.sol";
-+import {DiamondCutFacet} from "../src/facets/DiamondCutFacet.sol";
-+import {DiamondLoupeFacet} from "../src/facets/DiamondLoupeFacet.sol";
-+import {OwnershipFacet} from "../src/facets/OwnershipFacet.sol";
-+import {VaultCoreFacet} from "../src/facets/VaultCoreFacet.sol";
-+import {ClaimFacet} from "../src/facets/ClaimFacet.sol";
-+import {MintFacet} from "../src/facets/MintFacet.sol";
-+import {CallbackFacet} from "../src/facets/CallbackFacet.sol";
-+import {InitializationFacet} from "../src/facets/InitializationFacet.sol";
- 
- contract DeployDiamond is Script {
-     function run() external {
-@@ -18,13 +22,17 @@ contract DeployDiamond is Script {
-         DiamondCutFacet diamondCutFacet = new DiamondCutFacet();
-         DiamondLoupeFacet diamondLoupeFacet = new DiamondLoupeFacet();
-         OwnershipFacet ownershipFacet = new OwnershipFacet();
--        VaultFacet vaultFacet = new VaultFacet();
-+        VaultCoreFacet vaultCoreFacet = new VaultCoreFacet();
-+        ClaimFacet claimFacet = new ClaimFacet();
-+        MintFacet mintFacet = new MintFacet();
-+        CallbackFacet callbackFacet = new CallbackFacet();
-+        InitializationFacet initFacet = new InitializationFacet();
- 
-         // Deploy Diamond
-         Diamond diamond = new Diamond(msg.sender, address(diamondCutFacet));
- 
-         // Build cut struct
--        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);
-+        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](7);
- 
-         // DiamondLoupeFacet
-         bytes4[] memory loupeSelectors = new bytes4[](5);
-@@ -49,31 +57,89 @@ contract DeployDiamond is Script {
-             functionSelectors: ownershipSelectors
-         });
- 
--        // VaultFacet
--        bytes4[] memory vaultSelectors = new bytes4[](8);
--        vaultSelectors[0] = VaultFacet.lockToken.selector;
--        vaultSelectors[1] = VaultFacet.unlockToken.selector;
--        vaultSelectors[2] = VaultFacet.updateTokenURI.selector;
--        vaultSelectors[3] = VaultFacet.isTokenLocked.selector;
--        vaultSelectors[4] = VaultFacet.tokenOwner.selector;
--        vaultSelectors[5] = VaultFacet.getTokenURI.selector;
--        vaultSelectors[6] = VaultFacet.balanceOf.selector;
--        vaultSelectors[7] = VaultFacet.totalSupply.selector;
-+        // VaultCoreFacet
-+        bytes4[] memory vaultCoreSelectors = new bytes4[](13);
-+        vaultCoreSelectors[0] = VaultCoreFacet.lockVault.selector;
-+        vaultCoreSelectors[1] = VaultCoreFacet.unlockVault.selector;
-+        vaultCoreSelectors[2] = VaultCoreFacet.isVaultLocked.selector;
-+        vaultCoreSelectors[3] = VaultCoreFacet.addWitness.selector;
-+        vaultCoreSelectors[4] = VaultCoreFacet.removeWitness.selector;
-+        vaultCoreSelectors[5] = VaultCoreFacet.setRecipientAddress.selector;
-+        vaultCoreSelectors[6] = VaultCoreFacet.setQuoteContract.selector;
-+        vaultCoreSelectors[7] = VaultCoreFacet.setMetadataBaseUri.selector;
-+        vaultCoreSelectors[8] = VaultCoreFacet.registerContract.selector;
-+        vaultCoreSelectors[9] = VaultCoreFacet.unregisterContract.selector;
-+        vaultCoreSelectors[10] = VaultCoreFacet.getRegisteredContractsOfType.selector;
-+        vaultCoreSelectors[11] = VaultCoreFacet.isRegistered.selector;
-+        vaultCoreSelectors[12] = VaultCoreFacet.version.selector;
-         cut[2] = IDiamondCut.FacetCut({
--            facetAddress: address(vaultFacet),
-+            facetAddress: address(vaultCoreFacet),
-             action: IDiamondCut.FacetCutAction.Add,
--            functionSelectors: vaultSelectors
-+            functionSelectors: vaultCoreSelectors
-+        });
-+
-+        // ClaimFacet
-+        bytes4[] memory claimSelectors = new bytes4[](2);
-+        claimSelectors[0] = ClaimFacet.claim.selector;
-+        claimSelectors[1] = ClaimFacet.claimWithSignedPrice.selector;
-+        cut[3] = IDiamondCut.FacetCut({
-+            facetAddress: address(claimFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: claimSelectors
-+        });
-+
-+        // MintFacet
-+        bytes4[] memory mintSelectors = new bytes4[](2);
-+        mintSelectors[0] = MintFacet.buyWithSignedPrice.selector;
-+        mintSelectors[1] = MintFacet.buyWithQuote.selector;
-+        cut[4] = IDiamondCut.FacetCut({
-+            facetAddress: address(mintFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: mintSelectors
-+        });
-+
-+        // CallbackFacet
-+        bytes4[] memory callbackSelectors = new bytes4[](6);
-+        callbackSelectors[0] = CallbackFacet.executeCallbacks.selector;
-+        callbackSelectors[1] = CallbackFacet.registerCallback.selector;
-+        callbackSelectors[2] = CallbackFacet.registerWildcardCallback.selector;
-+        callbackSelectors[3] = CallbackFacet.hasCallback.selector;
-+        callbackSelectors[4] = CallbackFacet.unregisterCallback.selector;
-+        callbackSelectors[5] = CallbackFacet.toggleAllowCallbacks.selector;
-+        cut[5] = IDiamondCut.FacetCut({
-+            facetAddress: address(callbackFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: callbackSelectors
-+        });
-+
-+        // InitializationFacet
-+        bytes4[] memory initSelectors = new bytes4[](4);
-+        initSelectors[0] = InitializationFacet.initialize.selector;
-+        initSelectors[1] = InitializationFacet.isInitialized.selector;
-+        initSelectors[2] = InitializationFacet.getInterfaceIds.selector;
-+        initSelectors[3] = InitializationFacet.getConfiguration.selector;
-+        cut[6] = IDiamondCut.FacetCut({
-+            facetAddress: address(initFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: initSelectors
-         });
- 
-         // Add facets to diamond
-         IDiamondCut(address(diamond)).diamondCut(cut, address(0), "");
- 
-+        // Initialize the vault
-+        InitializationFacet(address(diamond)).initialize(msg.sender);
-+
-         vm.stopBroadcast();
- 
-         console.log("Diamond deployed at:", address(diamond));
-         console.log("DiamondCutFacet deployed at:", address(diamondCutFacet));
-         console.log("DiamondLoupeFacet deployed at:", address(diamondLoupeFacet));
-         console.log("OwnershipFacet deployed at:", address(ownershipFacet));
--        console.log("VaultFacet deployed at:", address(vaultFacet));
-+        console.log("VaultCoreFacet deployed at:", address(vaultCoreFacet));
-+        console.log("ClaimFacet deployed at:", address(claimFacet));
-+        console.log("MintFacet deployed at:", address(mintFacet));
-+        console.log("CallbackFacet deployed at:", address(callbackFacet));
-+        console.log("InitializationFacet deployed at:", address(initFacet));
-     }
- }
-diff --git a/test/DiamondVault.t.sol b/test/DiamondVault.t.sol
-index e1de1e1..9466ebd 100644
---- a/test/DiamondVault.t.sol
-+++ b/test/DiamondVault.t.sol
-@@ -2,19 +2,28 @@
- pragma solidity ^0.8.19;
- 
- import "forge-std/Test.sol";
--import "../src/Diamond.sol";
--import "../src/facets/DiamondCutFacet.sol";
--import "../src/facets/DiamondLoupeFacet.sol";
--import "../src/facets/OwnershipFacet.sol";
--import "../src/facets/VaultFacet.sol";
--import "../src/interfaces/IDiamondCut.sol";
-+import {Diamond} from "../src/Diamond.sol";
-+import {IDiamondCut} from "../src/interfaces/IDiamondCut.sol";
-+import {DiamondCutFacet} from "../src/facets/DiamondCutFacet.sol";
-+import {DiamondLoupeFacet} from "../src/facets/DiamondLoupeFacet.sol";
-+import {OwnershipFacet} from "../src/facets/OwnershipFacet.sol";
-+import {VaultCoreFacet} from "../src/facets/VaultCoreFacet.sol";
-+import {ClaimFacet} from "../src/facets/ClaimFacet.sol";
-+import {MintFacet} from "../src/facets/MintFacet.sol";
-+import {CallbackFacet} from "../src/facets/CallbackFacet.sol";
-+import {InitializationFacet} from "../src/facets/InitializationFacet.sol";
-+import {IHandlerCallback} from "../src/interfaces/IHandlerCallback.sol";
- 
- contract DiamondVaultTest is Test {
-     Diamond diamond;
-     DiamondCutFacet diamondCutFacet;
-     DiamondLoupeFacet diamondLoupeFacet;
-     OwnershipFacet ownershipFacet;
--    VaultFacet vaultFacet;
-+    VaultCoreFacet vaultCoreFacet;
-+    ClaimFacet claimFacet;
-+    MintFacet mintFacet;
-+    CallbackFacet callbackFacet;
-+    InitializationFacet initFacet;
- 
-     address owner = address(this);
-     address user1 = address(0x1);
-@@ -25,13 +34,17 @@ contract DiamondVaultTest is Test {
-         diamondCutFacet = new DiamondCutFacet();
-         diamondLoupeFacet = new DiamondLoupeFacet();
-         ownershipFacet = new OwnershipFacet();
--        vaultFacet = new VaultFacet();
-+        vaultCoreFacet = new VaultCoreFacet();
-+        claimFacet = new ClaimFacet();
-+        mintFacet = new MintFacet();
-+        callbackFacet = new CallbackFacet();
-+        initFacet = new InitializationFacet();
- 
-         // Deploy Diamond
-         diamond = new Diamond(owner, address(diamondCutFacet));
- 
-         // Build cut struct
--        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);
-+        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](7);
- 
-         // DiamondLoupeFacet
-         bytes4[] memory loupeSelectors = new bytes4[](5);
-@@ -56,83 +69,141 @@ contract DiamondVaultTest is Test {
-             functionSelectors: ownershipSelectors
-         });
- 
--        // VaultFacet
--        bytes4[] memory vaultSelectors = new bytes4[](8);
--        vaultSelectors[0] = VaultFacet.lockToken.selector;
--        vaultSelectors[1] = VaultFacet.unlockToken.selector;
--        vaultSelectors[2] = VaultFacet.updateTokenURI.selector;
--        vaultSelectors[3] = VaultFacet.isTokenLocked.selector;
--        vaultSelectors[4] = VaultFacet.tokenOwner.selector;
--        vaultSelectors[5] = VaultFacet.getTokenURI.selector;
--        vaultSelectors[6] = VaultFacet.balanceOf.selector;
--        vaultSelectors[7] = VaultFacet.totalSupply.selector;
-+        // VaultCoreFacet
-+        bytes4[] memory vaultCoreSelectors = new bytes4[](13);
-+        vaultCoreSelectors[0] = VaultCoreFacet.lockVault.selector;
-+        vaultCoreSelectors[1] = VaultCoreFacet.unlockVault.selector;
-+        vaultCoreSelectors[2] = VaultCoreFacet.isVaultLocked.selector;
-+        vaultCoreSelectors[3] = VaultCoreFacet.addWitness.selector;
-+        vaultCoreSelectors[4] = VaultCoreFacet.removeWitness.selector;
-+        vaultCoreSelectors[5] = VaultCoreFacet.setRecipientAddress.selector;
-+        vaultCoreSelectors[6] = VaultCoreFacet.setQuoteContract.selector;
-+        vaultCoreSelectors[7] = VaultCoreFacet.setMetadataBaseUri.selector;
-+        vaultCoreSelectors[8] = VaultCoreFacet.registerContract.selector;
-+        vaultCoreSelectors[9] = VaultCoreFacet.unregisterContract.selector;
-+        vaultCoreSelectors[10] = VaultCoreFacet.getRegisteredContractsOfType.selector;
-+        vaultCoreSelectors[11] = VaultCoreFacet.isRegistered.selector;
-+        vaultCoreSelectors[12] = VaultCoreFacet.version.selector;
-         cut[2] = IDiamondCut.FacetCut({
--            facetAddress: address(vaultFacet),
-+            facetAddress: address(vaultCoreFacet),
-             action: IDiamondCut.FacetCutAction.Add,
--            functionSelectors: vaultSelectors
-+            functionSelectors: vaultCoreSelectors
-+        });
-+
-+        // ClaimFacet
-+        bytes4[] memory claimSelectors = new bytes4[](2);
-+        claimSelectors[0] = ClaimFacet.claim.selector;
-+        claimSelectors[1] = ClaimFacet.claimWithSignedPrice.selector;
-+        cut[3] = IDiamondCut.FacetCut({
-+            facetAddress: address(claimFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: claimSelectors
-+        });
-+
-+        // MintFacet
-+        bytes4[] memory mintSelectors = new bytes4[](2);
-+        mintSelectors[0] = MintFacet.buyWithSignedPrice.selector;
-+        mintSelectors[1] = MintFacet.buyWithQuote.selector;
-+        cut[4] = IDiamondCut.FacetCut({
-+            facetAddress: address(mintFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: mintSelectors
-+        });
-+
-+        // CallbackFacet
-+        bytes4[] memory callbackSelectors = new bytes4[](6);
-+        callbackSelectors[0] = CallbackFacet.executeCallbacks.selector;
-+        callbackSelectors[1] = CallbackFacet.registerCallback.selector;
-+        callbackSelectors[2] = CallbackFacet.registerWildcardCallback.selector;
-+        callbackSelectors[3] = CallbackFacet.hasCallback.selector;
-+        callbackSelectors[4] = CallbackFacet.unregisterCallback.selector;
-+        callbackSelectors[5] = CallbackFacet.toggleAllowCallbacks.selector;
-+        cut[5] = IDiamondCut.FacetCut({
-+            facetAddress: address(callbackFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: callbackSelectors
-+        });
-+
-+        // InitializationFacet
-+        bytes4[] memory initSelectors = new bytes4[](4);
-+        initSelectors[0] = InitializationFacet.initialize.selector;
-+        initSelectors[1] = InitializationFacet.isInitialized.selector;
-+        initSelectors[2] = InitializationFacet.getInterfaceIds.selector;
-+        initSelectors[3] = InitializationFacet.getConfiguration.selector;
-+        cut[6] = IDiamondCut.FacetCut({
-+            facetAddress: address(initFacet),
-+            action: IDiamondCut.FacetCutAction.Add,
-+            functionSelectors: initSelectors
-         });
- 
-         // Add facets to diamond
-         IDiamondCut(address(diamond)).diamondCut(cut, address(0), "");
-+
-+        // Initialize the vault
-+        InitializationFacet(address(diamond)).initialize(owner);
-     }
- 
--    function testLockToken() public {
--        VaultFacet(address(diamond)).lockToken(1, "ipfs://token1");
-+    function testInitialization() public {
-+        assertTrue(InitializationFacet(address(diamond)).isInitialized());
-+        (string memory baseUri,,,,) = InitializationFacet(address(diamond)).getConfiguration();
-+        assertEq(baseUri, "https://v2.emblemvault.io/meta/");
-+    }
- 
--        assertTrue(VaultFacet(address(diamond)).isTokenLocked(1));
--        assertEq(VaultFacet(address(diamond)).tokenOwner(1), address(this));
--        assertEq(VaultFacet(address(diamond)).getTokenURI(1), "ipfs://token1");
--        assertEq(VaultFacet(address(diamond)).balanceOf(address(this)), 1);
--        assertEq(VaultFacet(address(diamond)).totalSupply(), 1);
-+    function testOwnership() public {
-+        assertEq(OwnershipFacet(address(diamond)).owner(), owner);
-     }
- 
--    function testUnlockToken() public {
--        VaultFacet(address(diamond)).lockToken(1, "ipfs://token1");
--        VaultFacet(address(diamond)).unlockToken(1);
-+    function testVaultLocking() public {
-+        address mockNft = address(0x123);
-+        uint256 tokenId = 1;
- 
--        assertFalse(VaultFacet(address(diamond)).isTokenLocked(1));
--        assertEq(VaultFacet(address(diamond)).tokenOwner(1), address(0));
--        assertEq(VaultFacet(address(diamond)).balanceOf(address(this)), 0);
--        assertEq(VaultFacet(address(diamond)).totalSupply(), 0);
--    }
-+        // Register mock NFT contract
-+        VaultCoreFacet(address(diamond)).registerContract(mockNft, 1);
- 
--    function testUpdateTokenURI() public {
--        VaultFacet(address(diamond)).lockToken(1, "ipfs://token1");
--        VaultFacet(address(diamond)).updateTokenURI(1, "ipfs://token1-updated");
-+        // Lock vault
-+        VaultCoreFacet(address(diamond)).lockVault(mockNft, tokenId);
-+        assertTrue(VaultCoreFacet(address(diamond)).isVaultLocked(mockNft, tokenId));
- 
--        assertEq(VaultFacet(address(diamond)).getTokenURI(1), "ipfs://token1-updated");
-+        // Unlock vault
-+        VaultCoreFacet(address(diamond)).unlockVault(mockNft, tokenId);
-+        assertFalse(VaultCoreFacet(address(diamond)).isVaultLocked(mockNft, tokenId));
-     }
- 
--    function testFailUnlockTokenNotOwner() public {
--        VaultFacet(address(diamond)).lockToken(1, "ipfs://token1");
-+    function testFailLockUnregisteredContract() public {
-+        address mockNft = address(0x123);
-+        uint256 tokenId = 1;
- 
--        vm.prank(user1);
--        VaultFacet(address(diamond)).unlockToken(1);
-+        VaultCoreFacet(address(diamond)).lockVault(mockNft, tokenId);
-     }
- 
--    function testFailLockTokenTwice() public {
--        VaultFacet(address(diamond)).lockToken(1, "ipfs://token1");
--        VaultFacet(address(diamond)).lockToken(1, "ipfs://token1");
--    }
-+    function testWitnessManagement() public {
-+        address witness = address(0x456);
- 
--    function testFailUpdateTokenURINotOwner() public {
--        VaultFacet(address(diamond)).lockToken(1, "ipfs://token1");
-+        // Add witness
-+        VaultCoreFacet(address(diamond)).addWitness(witness);
- 
--        vm.prank(user1);
--        VaultFacet(address(diamond)).updateTokenURI(1, "ipfs://token1-updated");
-+        // Remove witness
-+        VaultCoreFacet(address(diamond)).removeWitness(witness);
-     }
- 
--    function testOwnership() public {
--        assertEq(OwnershipFacet(address(diamond)).owner(), address(this));
-+    function testContractRegistration() public {
-+        address mockContract = address(0x789);
-+        uint256 contractType = 1;
-+
-+        // Register contract
-+        VaultCoreFacet(address(diamond)).registerContract(mockContract, contractType);
-+        assertTrue(VaultCoreFacet(address(diamond)).isRegistered(mockContract, contractType));
- 
--        OwnershipFacet(address(diamond)).transferOwnership(user1);
--        assertEq(OwnershipFacet(address(diamond)).owner(), user1);
-+        // Get registered contracts
-+        address[] memory contracts = VaultCoreFacet(address(diamond)).getRegisteredContractsOfType(contractType);
-+        assertEq(contracts.length, 1);
-+        assertEq(contracts[0], mockContract);
-     }
- 
--    function testDiamondCut() public view {
-+    function testDiamondCut() public {
-         // Test that all facets were properly added
-         address[] memory facetAddresses = DiamondLoupeFacet(address(diamond)).facetAddresses();
--        assertEq(facetAddresses.length, 4); // DiamondCut, DiamondLoupe, Ownership, and Vault facets
-+        assertEq(facetAddresses.length, 8); // All facets including DiamondCut
- 
-         // Verify DiamondCutFacet functions
-         assertEq(
-@@ -150,10 +221,5 @@ contract DiamondVaultTest is Test {
-         assertEq(
-             DiamondLoupeFacet(address(diamond)).getFacetAddress(OwnershipFacet.owner.selector), address(ownershipFacet)
-         );
--
--        // Verify VaultFacet functions
--        assertEq(
--            DiamondLoupeFacet(address(diamond)).getFacetAddress(VaultFacet.lockToken.selector), address(vaultFacet)
--        );
-     }
- }
diff --git a/lib/openzeppelin-contracts-upgradeable b/lib/openzeppelin-contracts-upgradeable
index 7f46c69..fa52531 160000
--- a/lib/openzeppelin-contracts-upgradeable
+++ b/lib/openzeppelin-contracts-upgradeable
@@ -1 +1 @@
-Subproject commit 7f46c690d2fe714e4a51eed4b1a601d9678b9b92
+Subproject commit fa525310e45f91eb20a6d3baa2644be8e0adba31
diff --git a/src/beacon/VaultBeacon.sol b/src/beacon/VaultBeacon.sol
index a1369f6..2c100c7 100644
--- a/src/beacon/VaultBeacon.sol
+++ b/src/beacon/VaultBeacon.sol
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.19;
 
-import "../interfaces/IERC165.sol";
+import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
 
 /**
  * @title VaultBeacon
diff --git a/src/beacon/VaultProxy.sol b/src/beacon/VaultProxy.sol
index 34d4bab..bc34f94 100644
--- a/src/beacon/VaultProxy.sol
+++ b/src/beacon/VaultProxy.sol
@@ -2,7 +2,7 @@
 pragma solidity ^0.8.19;
 
 import "./VaultBeacon.sol";
-import "../interfaces/IERC165.sol";
+import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
 
 /**
  * @title VaultProxy
diff --git a/src/factories/VaultFactory.sol b/src/factories/VaultFactory.sol
index 77571e0..7519fed 100644
--- a/src/factories/VaultFactory.sol
+++ b/src/factories/VaultFactory.sol
@@ -53,7 +53,7 @@ contract VaultFactory {
         // Deploy proxy
         vault = address(new ERC721VaultProxy(erc721Beacon));
 
-        // Initialize vault
+        // Initialize vault with default base URI
         try IERC721VaultProxy(vault).initialize(name, symbol) {
             emit ERC721VaultCreated(vault, name, symbol);
         } catch {
diff --git a/src/implementations/ERC1155VaultImplementation.sol b/src/implementations/ERC1155VaultImplementation.sol
index 44a0cf3..3ade3c3 100644
--- a/src/implementations/ERC1155VaultImplementation.sol
+++ b/src/implementations/ERC1155VaultImplementation.sol
@@ -1,211 +1,149 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.19;
 
-import "../interfaces/IERC1155.sol";
-import "../interfaces/IERC165.sol";
+import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
+import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
+import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
+import "../interfaces/IHandlerCallback.sol";
 import "../interfaces/IIsSerialized.sol";
+import "../interfaces/IVaultProxy.sol";
 
 /**
  * @title ERC1155VaultImplementation
- * @notice Implementation contract for ERC1155 vaults with serial number support
- * @dev Implements IERC1155, IIsSerialized, and IERC165 interfaces
+ * @notice Implementation of the ERC1155 vault token with serial number tracking
+ * @dev Implements ERC1155 with supply tracking and callback support
+ * TODO: Discuss with team about royalties enforcement strategy
  */
-contract ERC1155VaultImplementation {
-    // Storage slots follow EIP-1967 pattern to avoid clashes
-    bytes32 private constant INITIALIZED_SLOT = keccak256("erc1155.vault.initialized");
-    bytes32 private constant OWNER_SLOT = keccak256("erc1155.vault.owner");
-
-    // String storage
-    string private _uri;
-
-    // Mappings for ERC1155 functionality
-    mapping(uint256 => mapping(address => uint256)) private _balances;
-    mapping(address => mapping(address => bool)) private _operatorApprovals;
-
-    // Mappings for serial number functionality
+contract ERC1155VaultImplementation is
+    Initializable,
+    ERC1155Upgradeable,
+    ERC1155BurnableUpgradeable,
+    ERC1155SupplyUpgradeable,
+    OwnableUpgradeable,
+    ReentrancyGuardUpgradeable,
+    IIsSerialized,
+    IVaultProxy
+{
+    // Serial number tracking
     mapping(uint256 => mapping(uint256 => uint256)) private _tokenSerials; // tokenId => index => serialNumber
     mapping(uint256 => uint256) private _serialToTokenId; // serialNumber => tokenId
     mapping(address => mapping(uint256 => uint256[])) private _ownerTokenSerials; // owner => tokenId => serialNumbers[]
     mapping(uint256 => address) private _serialOwners; // serialNumber => owner
-    uint256 private _nextSerial = 1;
+    uint256 private _nextSerial;
 
-    // Events
-    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
-    event TransferBatch(
-        address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values
-    );
-    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
-    event URI(string value, uint256 indexed id);
-    event Initialized(string uri, address owner);
+    // Registered contracts by type
+    mapping(uint256 => address[]) public registeredOfType;
 
-    // Custom errors
-    error AlreadyInitialized();
-    error NotInitialized();
-    error ZeroAddress();
-    error NotOwner();
-    error NotApproved();
-    error InvalidBalance();
-    error InvalidSerial();
-    error LengthMismatch();
+    // Events
+    event SerialNumberAssigned(uint256 indexed tokenId, uint256 indexed serialNumber);
+    event ContractRegistered(uint256 indexed contractType, address indexed contractAddress);
+    event ContractUnregistered(uint256 indexed contractType, address indexed contractAddress);
 
-    modifier onlyInitialized() {
-        if (!_getInitialized()) revert NotInitialized();
-        _;
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
     }
 
-    modifier onlyOwner() {
-        if (msg.sender != _getOwner()) revert NotOwner();
-        _;
-    }
+    function initialize(string memory uri_) public initializer {
+        __ERC1155_init(uri_);
+        __ERC1155Burnable_init();
+        __ERC1155Supply_init();
+        __Ownable_init(msg.sender);
+        __ReentrancyGuard_init();
 
-    /**
-     * @notice Get the beacon address
-     * @return The address of the beacon contract
-     */
-    function beacon() external view returns (address) {
-        // This is called through the proxy, so we need to get the beacon from the proxy's storage
-        // The proxy stores the beacon address in a specific slot defined by EIP-1967
-        bytes32 slot = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
-        address beaconAddress;
-        assembly {
-            beaconAddress := sload(slot)
-        }
-        return beaconAddress;
+        _nextSerial = 1; // Start serial numbers at 1
     }
 
-    /**
-     * @notice Initialize the vault
-     * @param uri_ The base URI for token metadata
-     */
-    function initialize(string memory uri_) external {
-        if (_getInitialized()) revert AlreadyInitialized();
-
-        _uri = uri_;
-        _setOwner(msg.sender);
-        _setInitialized(true);
-
-        emit Initialized(uri_, msg.sender);
+    function registerContract(uint256 contractType, address contractAddress) external onlyOwner {
+        registeredOfType[contractType].push(contractAddress);
+        emit ContractRegistered(contractType, contractAddress);
     }
 
-    /**
-     * @notice Get the base URI
-     */
-    function uri(uint256) external view returns (string memory) {
-        return _uri;
-    }
-
-    /**
-     * @notice Check if interface is supported
-     */
-    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
-        return interfaceId == type(IERC1155).interfaceId || interfaceId == type(IERC165).interfaceId
-            || interfaceId == type(IIsSerialized).interfaceId;
+    function unregisterContract(uint256 contractType, address contractAddress) external onlyOwner {
+        address[] storage contracts = registeredOfType[contractType];
+        for (uint256 i = 0; i < contracts.length; i++) {
+            if (contracts[i] == contractAddress) {
+                contracts[i] = contracts[contracts.length - 1];
+                contracts.pop();
+                emit ContractUnregistered(contractType, contractAddress);
+                break;
+            }
+        }
     }
 
-    /**
-     * @notice Get balance of token for address
-     */
-    function balanceOf(address account, uint256 id) external view returns (uint256) {
-        if (account == address(0)) revert ZeroAddress();
-        return _balances[id][account];
+    function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {
+        _mint(to, id, amount, data);
     }
 
-    /**
-     * @notice Get balances for multiple token ids and addresses
-     */
-    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
+    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
         external
-        view
-        returns (uint256[] memory)
+        onlyOwner
     {
-        if (accounts.length != ids.length) revert LengthMismatch();
-
-        uint256[] memory batchBalances = new uint256[](accounts.length);
-        for (uint256 i = 0; i < accounts.length; ++i) {
-            batchBalances[i] = this.balanceOf(accounts[i], ids[i]);
-        }
-
-        return batchBalances;
-    }
-
-    /**
-     * @notice Set approval for all tokens
-     */
-    function setApprovalForAll(address operator, bool approved) external {
-        if (operator == msg.sender) revert("ERC1155: setting approval status for self");
-        _operatorApprovals[msg.sender][operator] = approved;
-        emit ApprovalForAll(msg.sender, operator, approved);
-    }
-
-    /**
-     * @notice Check if operator is approved for all tokens
-     */
-    function isApprovedForAll(address account, address operator) public view returns (bool) {
-        return _operatorApprovals[account][operator];
-    }
-
-    /**
-     * @notice Safe transfer of tokens
-     */
-    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external {
-        if (from != msg.sender && !isApprovedForAll(from, msg.sender)) revert NotApproved();
-        _safeTransferFrom(from, to, id, amount, data);
+        _mintBatch(to, ids, amounts, data);
     }
 
-    /**
-     * @notice Safe batch transfer of tokens
-     */
-    function safeBatchTransferFrom(
-        address from,
-        address to,
-        uint256[] calldata ids,
-        uint256[] calldata amounts,
-        bytes calldata data
-    ) external {
-        if (from != msg.sender && !isApprovedForAll(from, msg.sender)) revert NotApproved();
-        _safeBatchTransferFrom(from, to, ids, amounts, data);
-    }
-
-    /**
-     * @notice Mint tokens
-     * @param to Address to mint to
-     * @param id Token ID to mint
-     * @param amount Amount to mint
-     */
-    function mint(address to, uint256 id, uint256 amount) external onlyOwner {
-        _mint(to, id, amount, "");
-    }
-
-    /**
-     * @notice Batch mint tokens
-     * @param to Address to mint to
-     * @param ids Token IDs to mint
-     * @param amounts Amounts to mint
-     */
-    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) external onlyOwner {
-        _mintBatch(to, ids, amounts, "");
-    }
-
-    /**
-     * @notice Burn tokens
-     * @param from Address to burn from
-     * @param id Token ID to burn
-     * @param amount Amount to burn
-     */
-    function burn(address from, uint256 id, uint256 amount) external {
-        if (from != msg.sender && !isApprovedForAll(from, msg.sender)) revert NotApproved();
-        _burn(from, id, amount);
-    }
-
-    /**
-     * @notice Batch burn tokens
-     * @param from Address to burn from
-     * @param ids Token IDs to burn
-     * @param amounts Amounts to burn
-     */
-    function burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) external {
-        if (from != msg.sender && !isApprovedForAll(from, msg.sender)) revert NotApproved();
-        _burnBatch(from, ids, amounts);
+    function _update(address from, address to, uint256[] memory ids, uint256[] memory values)
+        internal
+        virtual
+        override(ERC1155Upgradeable, ERC1155SupplyUpgradeable)
+    {
+        super._update(from, to, ids, values);
+
+        // Handle minting
+        if (from == address(0) && to != address(0)) {
+            for (uint256 i = 0; i < ids.length; i++) {
+                for (uint256 j = 0; j < values[i]; j++) {
+                    uint256 serialNumber = _nextSerial++;
+                    _tokenSerials[ids[i]][j] = serialNumber;
+                    _serialToTokenId[serialNumber] = ids[i];
+                    _ownerTokenSerials[to][ids[i]].push(serialNumber);
+                    _serialOwners[serialNumber] = to;
+                    emit SerialNumberAssigned(ids[i], serialNumber);
+                }
+
+                // Execute callbacks if called by handler
+                if (registeredOfType[3].length > 0 && registeredOfType[3][0] == _msgSender()) {
+                    IHandlerCallback(_msgSender()).executeCallbacks(
+                        address(0), to, ids[i], IHandlerCallback.CallbackType.MINT
+                    );
+                }
+            }
+        }
+        // Handle burning
+        else if (to == address(0) && from != address(0)) {
+            for (uint256 i = 0; i < ids.length; i++) {
+                uint256[] storage serials = _ownerTokenSerials[from][ids[i]];
+                for (uint256 j = 0; j < values[i] && serials.length > 0; j++) {
+                    uint256 serialNumber = serials[serials.length - 1];
+                    delete _serialToTokenId[serialNumber];
+                    delete _serialOwners[serialNumber];
+                    serials.pop();
+                }
+
+                // Execute callbacks if handler is registered
+                if (registeredOfType[3].length > 0 && registeredOfType[3][0] != address(0)) {
+                    IHandlerCallback(registeredOfType[3][0]).executeCallbacks(
+                        _msgSender(), address(0), ids[i], IHandlerCallback.CallbackType.BURN
+                    );
+                }
+            }
+        }
+        // Handle transfers
+        else if (from != address(0) && to != address(0)) {
+            for (uint256 i = 0; i < ids.length; i++) {
+                uint256[] storage fromSerials = _ownerTokenSerials[from][ids[i]];
+                for (uint256 j = 0; j < values[i] && fromSerials.length > 0; j++) {
+                    uint256 serialNumber = fromSerials[fromSerials.length - 1];
+                    fromSerials.pop();
+                    _ownerTokenSerials[to][ids[i]].push(serialNumber);
+                    _serialOwners[serialNumber] = to;
+                }
+            }
+        }
     }
 
     // IIsSerialized Implementation
@@ -214,12 +152,12 @@ contract ERC1155VaultImplementation {
     }
 
     function getSerial(uint256 tokenId, uint256 index) external view returns (uint256) {
-        if (_tokenSerials[tokenId][index] == 0) revert InvalidSerial();
+        require(_tokenSerials[tokenId][index] != 0, "Invalid serial");
         return _tokenSerials[tokenId][index];
     }
 
     function getFirstSerialByOwner(address owner, uint256 tokenId) external view returns (uint256) {
-        if (_ownerTokenSerials[owner][tokenId].length == 0) revert InvalidSerial();
+        require(_ownerTokenSerials[owner][tokenId].length > 0, "No serials found");
         return _ownerTokenSerials[owner][tokenId][0];
     }
 
@@ -228,7 +166,7 @@ contract ERC1155VaultImplementation {
     }
 
     function getSerialByOwnerAtIndex(address owner, uint256 tokenId, uint256 index) external view returns (uint256) {
-        if (index >= _ownerTokenSerials[owner][tokenId].length) revert InvalidSerial();
+        require(index < _ownerTokenSerials[owner][tokenId].length, "Invalid index");
         return _ownerTokenSerials[owner][tokenId][index];
     }
 
@@ -240,234 +178,33 @@ contract ERC1155VaultImplementation {
         return false;
     }
 
-    // Internal functions
-    function _safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) internal {
-        if (to == address(0)) revert ZeroAddress();
-
-        address operator = msg.sender;
-        uint256[] memory ids = new uint256[](1);
-        uint256[] memory amounts = new uint256[](1);
-        ids[0] = id;
-        amounts[0] = amount;
-
-        _beforeTokenTransfer(operator, from, to, ids, amounts, data);
-
-        uint256 fromBalance = _balances[id][from];
-        if (fromBalance < amount) revert InvalidBalance();
-        unchecked {
-            _balances[id][from] = fromBalance - amount;
-        }
-        _balances[id][to] += amount;
-
-        // Transfer serial numbers
-        uint256[] storage fromSerials = _ownerTokenSerials[from][id];
-        for (uint256 i = 0; i < amount && fromSerials.length > 0; i++) {
-            uint256 serialNumber = fromSerials[fromSerials.length - 1];
-            fromSerials.pop();
-            _ownerTokenSerials[to][id].push(serialNumber);
-            _serialOwners[serialNumber] = to;
-        }
-
-        emit TransferSingle(operator, from, to, id, amount);
-        _afterTokenTransfer(operator, from, to, ids, amounts, data);
-    }
-
-    function _safeBatchTransferFrom(
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal {
-        if (ids.length != amounts.length) revert LengthMismatch();
-        if (to == address(0)) revert ZeroAddress();
-
-        address operator = msg.sender;
-
-        _beforeTokenTransfer(operator, from, to, ids, amounts, data);
-
-        for (uint256 i = 0; i < ids.length; ++i) {
-            uint256 id = ids[i];
-            uint256 amount = amounts[i];
-
-            uint256 fromBalance = _balances[id][from];
-            if (fromBalance < amount) revert InvalidBalance();
-            unchecked {
-                _balances[id][from] = fromBalance - amount;
-            }
-            _balances[id][to] += amount;
-
-            // Transfer serial numbers
-            uint256[] storage fromSerials = _ownerTokenSerials[from][id];
-            for (uint256 j = 0; j < amount && fromSerials.length > 0; j++) {
-                uint256 serialNumber = fromSerials[fromSerials.length - 1];
-                fromSerials.pop();
-                _ownerTokenSerials[to][id].push(serialNumber);
-                _serialOwners[serialNumber] = to;
-            }
-        }
-
-        emit TransferBatch(operator, from, to, ids, amounts);
-        _afterTokenTransfer(operator, from, to, ids, amounts, data);
-    }
-
-    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal {
-        if (to == address(0)) revert ZeroAddress();
-
-        address operator = msg.sender;
-        uint256[] memory ids = new uint256[](1);
-        uint256[] memory amounts = new uint256[](1);
-        ids[0] = id;
-        amounts[0] = amount;
-
-        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);
-
-        _balances[id][to] += amount;
-
-        // Create serial numbers
-        for (uint256 i = 0; i < amount; i++) {
-            uint256 serialNumber = _nextSerial++;
-            _tokenSerials[id][i] = serialNumber;
-            _serialToTokenId[serialNumber] = id;
-            _ownerTokenSerials[to][id].push(serialNumber);
-            _serialOwners[serialNumber] = to;
-        }
-
-        emit TransferSingle(operator, address(0), to, id, amount);
-        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);
-    }
-
-    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal {
-        if (to == address(0)) revert ZeroAddress();
-        if (ids.length != amounts.length) revert LengthMismatch();
-
-        address operator = msg.sender;
-
-        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);
-
-        for (uint256 i = 0; i < ids.length; i++) {
-            _balances[ids[i]][to] += amounts[i];
-
-            // Create serial numbers
-            for (uint256 j = 0; j < amounts[i]; j++) {
-                uint256 serialNumber = _nextSerial++;
-                _tokenSerials[ids[i]][j] = serialNumber;
-                _serialToTokenId[serialNumber] = ids[i];
-                _ownerTokenSerials[to][ids[i]].push(serialNumber);
-                _serialOwners[serialNumber] = to;
-            }
-        }
-
-        emit TransferBatch(operator, address(0), to, ids, amounts);
-        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);
-    }
-
-    function _burn(address from, uint256 id, uint256 amount) internal {
-        if (from == address(0)) revert ZeroAddress();
-
-        address operator = msg.sender;
-        uint256[] memory ids = new uint256[](1);
-        uint256[] memory amounts = new uint256[](1);
-        ids[0] = id;
-        amounts[0] = amount;
-
-        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");
-
-        uint256 fromBalance = _balances[id][from];
-        if (fromBalance < amount) revert InvalidBalance();
-        unchecked {
-            _balances[id][from] = fromBalance - amount;
-        }
-
-        // Remove serial numbers
-        uint256[] storage serials = _ownerTokenSerials[from][id];
-        for (uint256 i = 0; i < amount && serials.length > 0; i++) {
-            uint256 serialNumber = serials[serials.length - 1];
-            delete _serialToTokenId[serialNumber];
-            delete _serialOwners[serialNumber];
-            serials.pop();
-        }
-
-        emit TransferSingle(operator, from, address(0), id, amount);
-        _afterTokenTransfer(operator, from, address(0), ids, amounts, "");
-    }
-
-    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal {
-        if (from == address(0)) revert ZeroAddress();
-        if (ids.length != amounts.length) revert LengthMismatch();
-
-        address operator = msg.sender;
-
-        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");
-
-        for (uint256 i = 0; i < ids.length; i++) {
-            uint256 id = ids[i];
-            uint256 amount = amounts[i];
-
-            uint256 fromBalance = _balances[id][from];
-            if (fromBalance < amount) revert InvalidBalance();
-            unchecked {
-                _balances[id][from] = fromBalance - amount;
-            }
-
-            // Remove serial numbers
-            uint256[] storage serials = _ownerTokenSerials[from][id];
-            for (uint256 j = 0; j < amount && serials.length > 0; j++) {
-                uint256 serialNumber = serials[serials.length - 1];
-                delete _serialToTokenId[serialNumber];
-                delete _serialOwners[serialNumber];
-                serials.pop();
-            }
-        }
-
-        emit TransferBatch(operator, from, address(0), ids, amounts);
-        _afterTokenTransfer(operator, from, address(0), ids, amounts, "");
-    }
-
-    function _beforeTokenTransfer(
-        address operator,
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal virtual {}
-
-    function _afterTokenTransfer(
-        address operator,
-        address from,
-        address to,
-        uint256[] memory ids,
-        uint256[] memory amounts,
-        bytes memory data
-    ) internal virtual {}
-
-    // Storage getters and setters
-    function _getInitialized() internal view returns (bool initialized_) {
-        bytes32 slot = INITIALIZED_SLOT;
-        assembly {
-            initialized_ := sload(slot)
-        }
+    function supportsInterface(bytes4 interfaceId)
+        public
+        view
+        virtual
+        override(ERC1155Upgradeable, IERC165)
+        returns (bool)
+    {
+        return interfaceId == type(IIsSerialized).interfaceId || interfaceId == type(IVaultProxy).interfaceId
+            || super.supportsInterface(interfaceId);
     }
 
-    function _setInitialized(bool initialized_) internal {
-        bytes32 slot = INITIALIZED_SLOT;
-        assembly {
-            sstore(slot, initialized_)
-        }
+    function version() external pure returns (string memory) {
+        return "2.0.0";
     }
 
-    function _getOwner() internal view returns (address owner_) {
-        bytes32 slot = OWNER_SLOT;
+    // IVaultProxy Implementation
+    function beacon() external view returns (address) {
+        // Get the beacon slot from EIP-1967
+        bytes32 slot = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
+        address beaconAddress;
         assembly {
-            owner_ := sload(slot)
+            beaconAddress := sload(slot)
         }
+        return beaconAddress;
     }
 
-    function _setOwner(address owner_) internal {
-        bytes32 slot = OWNER_SLOT;
-        assembly {
-            sstore(slot, owner_)
-        }
+    function implementation() external view returns (address) {
+        return address(this);
     }
 }
diff --git a/src/implementations/ERC721VaultImplementation.sol b/src/implementations/ERC721VaultImplementation.sol
index ffde02e..a8d8bb0 100644
--- a/src/implementations/ERC721VaultImplementation.sol
+++ b/src/implementations/ERC721VaultImplementation.sol
@@ -1,212 +1,179 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.19;
 
-import "../interfaces/IERC721.sol";
-import "../interfaces/IERC165.sol";
+import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
+import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
+import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
+import "../interfaces/IHandlerCallback.sol";
 import "../interfaces/IIsSerialized.sol";
+import "../interfaces/IVaultProxy.sol";
 
 /**
  * @title ERC721VaultImplementation
- * @notice Implementation contract for ERC721 vaults with serial number support
- * @dev Implements IERC721, IIsSerialized, and IERC165 interfaces
+ * @notice Implementation of the ERC721 vault token with serial number tracking
+ * @dev Implements ERC721 with enumerable extension and callback support
+ * TODO: Discuss with team about royalties enforcement strategy
  */
-contract ERC721VaultImplementation {
-    // Storage slots follow EIP-1967 pattern to avoid clashes
-    bytes32 private constant INITIALIZED_SLOT = keccak256("erc721.vault.initialized");
-    bytes32 private constant OWNER_SLOT = keccak256("erc721.vault.owner");
-
-    // String storage
-    string private _name;
-    string private _symbol;
-
-    // Mappings for ERC721 functionality
-    mapping(uint256 => address) private _owners;
-    mapping(address => uint256) private _balances;
-    mapping(uint256 => address) private _tokenApprovals;
-    mapping(address => mapping(address => bool)) private _operatorApprovals;
-    mapping(uint256 => string) private _tokenURIs;
-
-    // Mappings for serial number functionality
+contract ERC721VaultImplementation is
+    Initializable,
+    ERC721Upgradeable,
+    ERC721BurnableUpgradeable,
+    ERC721EnumerableUpgradeable,
+    OwnableUpgradeable,
+    ReentrancyGuardUpgradeable,
+    IIsSerialized,
+    IVaultProxy
+{
+    // Storage
+    mapping(uint256 => uint256) internal _externalTokenIdMap; // tokenId >> externalTokenId
+    string private _baseTokenURI;
+
+    // Serial number tracking
     mapping(uint256 => uint256) private _tokenIdToSerial;
     mapping(uint256 => uint256) private _serialToTokenId;
     mapping(address => mapping(uint256 => uint256[])) private _ownerTokenSerials;
     mapping(uint256 => address) private _serialOwners;
-    uint256 private _nextSerial = 1;
-
-    // Events from IERC721
-    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
-    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
-    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
-
-    // Custom events
-    event Initialized(string name, string symbol, address owner);
-
-    // Custom errors
-    error AlreadyInitialized();
-    error NotInitialized();
-    error ZeroAddress();
-    error NotOwner();
-    error NotApproved();
-    error TokenNotFound();
-    error InvalidSerial();
-
-    modifier onlyInitialized() {
-        if (!_getInitialized()) revert NotInitialized();
-        _;
-    }
+    uint256 private _nextSerial;
 
-    modifier onlyOwner() {
-        if (msg.sender != _getOwner()) revert NotOwner();
-        _;
-    }
+    // Registered contracts by type
+    mapping(uint256 => address[]) public registeredOfType;
 
-    /**
-     * @notice Get the beacon address
-     * @return The address of the beacon contract
-     */
-    function beacon() external view returns (address) {
-        // This is called through the proxy, so we need to get the beacon from the proxy's storage
-        // The proxy stores the beacon address in a specific slot defined by EIP-1967
-        bytes32 slot = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
-        address beaconAddress;
-        assembly {
-            beaconAddress := sload(slot)
-        }
-        return beaconAddress;
-    }
+    // Events
+    event SerialNumberAssigned(uint256 indexed tokenId, uint256 indexed serialNumber);
+    event ContractRegistered(uint256 indexed contractType, address indexed contractAddress);
+    event ContractUnregistered(uint256 indexed contractType, address indexed contractAddress);
 
-    /**
-     * @notice Initialize the vault
-     * @param name_ The name of the token
-     * @param symbol_ The symbol of the token
-     */
-    function initialize(string memory name_, string memory symbol_) external {
-        if (_getInitialized()) revert AlreadyInitialized();
-
-        _name = name_;
-        _symbol = symbol_;
-        _setOwner(msg.sender);
-        _nextSerial = 1; // Ensure serial numbers start at 1
-        _setInitialized(true);
-
-        emit Initialized(name_, symbol_, msg.sender);
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
     }
 
-    /**
-     * @notice Get the name of the token
-     */
-    function name() external view returns (string memory) {
-        return _name;
-    }
-
-    /**
-     * @notice Get the symbol of the token
-     */
-    function symbol() external view returns (string memory) {
-        return _symbol;
-    }
+    function initialize(string memory name_, string memory symbol_) public initializer {
+        __ERC721_init(name_, symbol_);
+        __ERC721Burnable_init();
+        __ERC721Enumerable_init();
+        __Ownable_init(msg.sender);
+        __ReentrancyGuard_init();
 
-    /**
-     * @notice Check if interface is supported
-     */
-    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
-        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC165).interfaceId
-            || interfaceId == type(IIsSerialized).interfaceId;
+        _baseTokenURI = "https://v2.emblemvault.io/meta/"; // Default base URI
+        _nextSerial = 1; // Start serial numbers at 1
     }
 
-    /**
-     * @notice Get balance of an address
-     */
-    function balanceOf(address owner) external view returns (uint256) {
-        if (owner == address(0)) revert ZeroAddress();
-        return _balances[owner];
+    function registerContract(uint256 contractType, address contractAddress) external onlyOwner {
+        registeredOfType[contractType].push(contractAddress);
+        emit ContractRegistered(contractType, contractAddress);
     }
 
-    /**
-     * @notice Get owner of a token
-     */
-    function ownerOf(uint256 tokenId) public view returns (address) {
-        address owner = _owners[tokenId];
-        if (owner == address(0)) revert TokenNotFound();
-        return owner;
-    }
-
-    /**
-     * @notice Approve an address to transfer a token
-     */
-    function approve(address to, uint256 tokenId) external {
-        address owner = ownerOf(tokenId);
-        if (to == owner) revert("ERC721: approval to current owner");
-        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {
-            revert NotApproved();
+    function unregisterContract(uint256 contractType, address contractAddress) external onlyOwner {
+        address[] storage contracts = registeredOfType[contractType];
+        for (uint256 i = 0; i < contracts.length; i++) {
+            if (contracts[i] == contractAddress) {
+                contracts[i] = contracts[contracts.length - 1];
+                contracts.pop();
+                emit ContractUnregistered(contractType, contractAddress);
+                break;
+            }
         }
-
-        _tokenApprovals[tokenId] = to;
-        emit Approval(owner, to, tokenId);
     }
 
-    /**
-     * @notice Get approved address for a token
-     */
-    function getApproved(uint256 tokenId) external view returns (address) {
-        return _getApproved(tokenId);
-    }
-
-    /**
-     * @notice Set approval for all tokens
-     */
-    function setApprovalForAll(address operator, bool approved) external {
-        if (operator == msg.sender) revert("ERC721: approve to caller");
-        _operatorApprovals[msg.sender][operator] = approved;
-        emit ApprovalForAll(msg.sender, operator, approved);
+    function mint(address to, uint256 tokenId) external onlyOwner {
+        _safeMint(to, tokenId);
     }
 
-    /**
-     * @notice Check if an operator is approved for all tokens
-     */
-    function isApprovedForAll(address owner, address operator) public view returns (bool) {
-        return _operatorApprovals[owner][operator];
+    function mintMany(address[] memory to, uint256[] memory tokenId) external onlyOwner {
+        require(to.length == tokenId.length, "Invalid input");
+        for (uint256 i = 0; i < to.length; i++) {
+            _safeMint(to[i], tokenId[i]);
+        }
     }
 
-    /**
-     * @notice Transfer a token
-     */
-    function transferFrom(address from, address to, uint256 tokenId) external {
-        if (!_isApprovedOrOwner(msg.sender, tokenId)) revert NotApproved();
-        _transfer(from, to, tokenId);
-    }
+    function _update(address to, uint256 tokenId, address auth)
+        internal
+        virtual
+        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
+        returns (address)
+    {
+        address from = super._update(to, tokenId, auth);
+
+        // Handle minting
+        if (from == address(0) && to != address(0)) {
+            require(_externalTokenIdMap[tokenId] == 0, "External ID already minted");
+            _externalTokenIdMap[tokenId] = tokenId;
+
+            // Create and assign serial number
+            uint256 serialNumber = _nextSerial++;
+            _tokenIdToSerial[tokenId] = serialNumber;
+            _serialToTokenId[serialNumber] = tokenId;
+            _serialOwners[serialNumber] = to;
+            _ownerTokenSerials[to][tokenId].push(serialNumber);
+
+            emit SerialNumberAssigned(tokenId, serialNumber);
+
+            // Execute callbacks if called by handler
+            if (registeredOfType[3].length > 0 && registeredOfType[3][0] == _msgSender()) {
+                IHandlerCallback(_msgSender()).executeCallbacks(
+                    address(0), to, tokenId, IHandlerCallback.CallbackType.MINT
+                );
+            }
+        }
+        // Handle burning
+        else if (to == address(0) && from != address(0)) {
+            // Clear serial number data
+            uint256 serialNumber = _tokenIdToSerial[tokenId];
+            delete _tokenIdToSerial[tokenId];
+            delete _serialToTokenId[serialNumber];
+            delete _serialOwners[serialNumber];
+            delete _externalTokenIdMap[tokenId];
+
+            // Remove from owner's serial list
+            uint256[] storage serials = _ownerTokenSerials[from][tokenId];
+            for (uint256 i = 0; i < serials.length; i++) {
+                if (serials[i] == serialNumber) {
+                    serials[i] = serials[serials.length - 1];
+                    serials.pop();
+                    break;
+                }
+            }
 
-    /**
-     * @notice Safely transfer a token
-     */
-    function safeTransferFrom(address from, address to, uint256 tokenId) external {
-        safeTransferFrom(from, to, tokenId, "");
-    }
+            // Execute callbacks if handler is registered
+            if (registeredOfType[3].length > 0 && registeredOfType[3][0] != address(0)) {
+                IHandlerCallback(registeredOfType[3][0]).executeCallbacks(
+                    _msgSender(), address(0), tokenId, IHandlerCallback.CallbackType.BURN
+                );
+            }
+        }
+        // Handle transfers
+        else if (from != address(0) && to != address(0)) {
+            // Update serial number ownership
+            uint256 serialNumber = _tokenIdToSerial[tokenId];
+            _serialOwners[serialNumber] = to;
+            _ownerTokenSerials[to][tokenId].push(serialNumber);
+
+            // Remove from previous owner's serial list
+            uint256[] storage serials = _ownerTokenSerials[from][tokenId];
+            for (uint256 i = 0; i < serials.length; i++) {
+                if (serials[i] == serialNumber) {
+                    serials[i] = serials[serials.length - 1];
+                    serials.pop();
+                    break;
+                }
+            }
+        }
 
-    /**
-     * @notice Safely transfer a token with data
-     */
-    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {
-        if (!_isApprovedOrOwner(msg.sender, tokenId)) revert NotApproved();
-        _safeTransfer(from, to, tokenId, data);
+        return from;
     }
 
-    /**
-     * @notice Mint a new token
-     * @param to Address to mint to
-     * @param tokenId Token ID to mint
-     */
-    function mint(address to, uint256 tokenId) external onlyOwner {
-        _safeMint(to, tokenId);
+    // Base URI
+    function _baseURI() internal view virtual override returns (string memory) {
+        return _baseTokenURI;
     }
 
-    /**
-     * @notice Burn a token
-     * @param tokenId Token ID to burn
-     */
-    function burn(uint256 tokenId) external {
-        if (!_isApprovedOrOwner(msg.sender, tokenId)) revert NotApproved();
-        _burn(tokenId);
+    function setBaseURI(string memory baseURI) external onlyOwner {
+        _baseTokenURI = baseURI;
     }
 
     // IIsSerialized Implementation
@@ -216,12 +183,12 @@ contract ERC721VaultImplementation {
 
     function getSerial(uint256 tokenId, uint256 index) external view returns (uint256) {
         address owner = ownerOf(tokenId);
-        if (index >= _ownerTokenSerials[owner][tokenId].length) revert InvalidSerial();
+        require(index < _ownerTokenSerials[owner][tokenId].length, "Invalid index");
         return _ownerTokenSerials[owner][tokenId][index];
     }
 
     function getFirstSerialByOwner(address owner, uint256 tokenId) external view returns (uint256) {
-        if (_ownerTokenSerials[owner][tokenId].length == 0) revert InvalidSerial();
+        require(_ownerTokenSerials[owner][tokenId].length > 0, "No serials found");
         return _ownerTokenSerials[owner][tokenId][0];
     }
 
@@ -230,7 +197,7 @@ contract ERC721VaultImplementation {
     }
 
     function getSerialByOwnerAtIndex(address owner, uint256 tokenId, uint256 index) external view returns (uint256) {
-        if (index >= _ownerTokenSerials[owner][tokenId].length) revert InvalidSerial();
+        require(index < _ownerTokenSerials[owner][tokenId].length, "Invalid index");
         return _ownerTokenSerials[owner][tokenId][index];
     }
 
@@ -242,177 +209,46 @@ contract ERC721VaultImplementation {
         return false;
     }
 
-    // Internal functions
-    function _exists(uint256 tokenId) internal view returns (bool) {
-        return _owners[tokenId] != address(0);
-    }
-
-    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
-        address owner = ownerOf(tokenId);
-        return (spender == owner || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);
-    }
-
-    function _getApproved(uint256 tokenId) internal view returns (address) {
-        if (!_exists(tokenId)) revert TokenNotFound();
-        return _tokenApprovals[tokenId];
+    // External token ID mapping
+    function getInternalTokenId(uint256 tokenId) external view returns (uint256) {
+        return _externalTokenIdMap[tokenId];
     }
 
-    function _safeMint(address to, uint256 tokenId) internal virtual {
-        _safeMint(to, tokenId, "");
-    }
-
-    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {
-        _mint(to, tokenId);
-        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {
-            revert("ERC721: transfer to non ERC721Receiver implementer");
-        }
-    }
-
-    function _mint(address to, uint256 tokenId) internal virtual {
-        if (to == address(0)) revert ZeroAddress();
-        if (_exists(tokenId)) revert("ERC721: token already minted");
-
-        // Update token ownership
-        _balances[to] += 1;
-        _owners[tokenId] = to;
-
-        // Create and assign serial number
-        uint256 serialNumber = _nextSerial++;
-        require(serialNumber != 0, "ERC721: invalid serial");
-
-        // Update serial number mappings
-        _tokenIdToSerial[tokenId] = serialNumber;
-        _serialToTokenId[serialNumber] = tokenId;
-        _serialOwners[serialNumber] = to;
-        _ownerTokenSerials[to][tokenId].push(serialNumber);
-
-        emit Transfer(address(0), to, tokenId);
-    }
-
-    function _burn(uint256 tokenId) internal virtual {
-        address owner = ownerOf(tokenId);
-
-        // Clear approvals
-        delete _tokenApprovals[tokenId];
-
-        _balances[owner] -= 1;
-        delete _owners[tokenId];
-
-        // Clear serial number data
-        uint256 serialNumber = _tokenIdToSerial[tokenId];
-        delete _tokenIdToSerial[tokenId];
-        delete _serialToTokenId[serialNumber];
-        delete _serialOwners[serialNumber];
-
-        // Remove from owner's serial list
-        uint256[] storage serials = _ownerTokenSerials[owner][tokenId];
-        for (uint256 i = 0; i < serials.length; i++) {
-            if (serials[i] == serialNumber) {
-                serials[i] = serials[serials.length - 1];
-                serials.pop();
-                break;
-            }
-        }
-
-        emit Transfer(owner, address(0), tokenId);
-    }
-
-    function _transfer(address from, address to, uint256 tokenId) internal virtual {
-        if (ownerOf(tokenId) != from) revert("ERC721: transfer from incorrect owner");
-        if (to == address(0)) revert ZeroAddress();
-
-        // Clear approvals from the previous owner
-        delete _tokenApprovals[tokenId];
-
-        // Get the serial number and verify it exists
-        uint256 serialNumber = _tokenIdToSerial[tokenId];
-        if (serialNumber == 0) revert("ERC721: token has no serial");
-
-        // Update token ownership first
-        _balances[from] -= 1;
-        _balances[to] += 1;
-        _owners[tokenId] = to;
-
-        // Update serial number ownership
-        _serialOwners[serialNumber] = to;
-
-        // Remove serial from previous owner
-        uint256[] storage fromSerials = _ownerTokenSerials[from][tokenId];
-        for (uint256 i = 0; i < fromSerials.length; i++) {
-            if (fromSerials[i] == serialNumber) {
-                fromSerials[i] = fromSerials[fromSerials.length - 1];
-                fromSerials.pop();
-                break;
-            }
-        }
-
-        // Add serial to new owner
-        _ownerTokenSerials[to][tokenId].push(serialNumber);
-
-        emit Transfer(from, to, tokenId);
-    }
-
-    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
-        _transfer(from, to, tokenId);
-        if (!_checkOnERC721Received(from, to, tokenId, data)) {
-            revert("ERC721: transfer to non ERC721Receiver implementer");
-        }
-    }
-
-    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)
-        private
+    function supportsInterface(bytes4 interfaceId)
+        public
+        view
+        virtual
+        override(ERC721Upgradeable, ERC721EnumerableUpgradeable, IERC165)
         returns (bool)
     {
-        if (to.code.length > 0) {
-            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
-                return retval == IERC721Receiver.onERC721Received.selector;
-            } catch (bytes memory reason) {
-                if (reason.length == 0) {
-                    revert("ERC721: transfer to non ERC721Receiver implementer");
-                } else {
-                    /// @solidity memory-safe-assembly
-                    assembly {
-                        revert(add(32, reason), mload(reason))
-                    }
-                }
-            }
-        } else {
-            return true;
-        }
+        return interfaceId == type(IIsSerialized).interfaceId || interfaceId == type(IVaultProxy).interfaceId
+            || super.supportsInterface(interfaceId);
     }
 
-    // Storage getters and setters
-    function _getInitialized() internal view returns (bool initialized_) {
-        bytes32 slot = INITIALIZED_SLOT;
-        assembly {
-            initialized_ := sload(slot)
-        }
+    function version() external pure returns (string memory) {
+        return "2.0.0";
     }
 
-    function _setInitialized(bool initialized_) internal {
-        bytes32 slot = INITIALIZED_SLOT;
-        assembly {
-            sstore(slot, initialized_)
-        }
+    function _increaseBalance(address account, uint128 value)
+        internal
+        virtual
+        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
+    {
+        super._increaseBalance(account, value);
     }
 
-    function _getOwner() internal view returns (address owner_) {
-        bytes32 slot = OWNER_SLOT;
+    // IVaultProxy Implementation
+    function beacon() external view returns (address) {
+        // Get the beacon slot from EIP-1967
+        bytes32 slot = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
+        address beaconAddress;
         assembly {
-            owner_ := sload(slot)
+            beaconAddress := sload(slot)
         }
+        return beaconAddress;
     }
 
-    function _setOwner(address owner_) internal {
-        bytes32 slot = OWNER_SLOT;
-        assembly {
-            sstore(slot, owner_)
-        }
+    function implementation() external view returns (address) {
+        return address(this);
     }
 }
-
-interface IERC721Receiver {
-    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)
-        external
-        returns (bytes4);
-}
diff --git a/src/interfaces/IHandlerCallback.sol b/src/interfaces/IHandlerCallback.sol
index 558446b..234fd2b 100644
--- a/src/interfaces/IHandlerCallback.sol
+++ b/src/interfaces/IHandlerCallback.sol
@@ -16,4 +16,6 @@ interface IHandlerCallback {
         bytes4 targetFunction;
         bool canRevert;
     }
+
+    function executeCallbacks(address from, address to, uint256 tokenId, CallbackType callbackType) external;
 }
diff --git a/src/interfaces/IVaultBeacon.sol b/src/interfaces/IVaultBeacon.sol
index b87a98f..554e5bf 100644
--- a/src/interfaces/IVaultBeacon.sol
+++ b/src/interfaces/IVaultBeacon.sol
@@ -1,11 +1,13 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.19;
 
+import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
+
 /**
  * @title IVaultBeacon
  * @notice Interface for vault beacon contracts
  */
-interface IVaultBeacon {
+interface IVaultBeacon is IERC165 {
     /**
      * @notice Get the current implementation address
      * @return The address of the current implementation
@@ -30,13 +32,6 @@ interface IVaultBeacon {
      */
     function transferOwnership(address newOwner) external;
 
-    /**
-     * @notice Check if interface is supported
-     * @param interfaceId The interface identifier
-     * @return bool True if the interface is supported
-     */
-    function supportsInterface(bytes4 interfaceId) external view returns (bool);
-
     /**
      * @dev Custom errors
      */
diff --git a/src/interfaces/IVaultProxy.sol b/src/interfaces/IVaultProxy.sol
index fc3cde4..fcbde49 100644
--- a/src/interfaces/IVaultProxy.sol
+++ b/src/interfaces/IVaultProxy.sol
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.19;
 
-import "./IERC165.sol";
+import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
 
 /**
  * @title IVaultProxy
diff --git a/src/libraries/LibEmblemVaultStorage.sol b/src/libraries/LibEmblemVaultStorage.sol
index 4198ead..2235735 100644
--- a/src/libraries/LibEmblemVaultStorage.sol
+++ b/src/libraries/LibEmblemVaultStorage.sol
@@ -179,6 +179,7 @@ library LibEmblemVaultStorage {
         vs.INTERFACE_ID_ERC721 = 0x80ac58cd;
         vs.INTERFACE_ID_ERC721A = 0xf4a95f26;
         vs.recipientAddress = msg.sender;
+        vs.vaultFactory = msg.sender;
         vs.allowCallbacks = true;
         vs.initialized = true;
     }
diff --git a/test/BeaconSystem.t.sol b/test/BeaconSystem.t.sol
index 93e3c10..9190d83 100644
--- a/test/BeaconSystem.t.sol
+++ b/test/BeaconSystem.t.sol
@@ -104,7 +104,7 @@ contract BeaconSystemTest is Test {
 
         // Test minting (factory is the owner)
         vm.prank(address(factory));
-        ERC1155VaultImplementation(vault).mint(user1, 1, 5);
+        ERC1155VaultImplementation(vault).mint(user1, 1, 5, "");
         assertEq(ERC1155VaultImplementation(vault).balanceOf(user1, 1), 5);
 
         // Test transfers
@@ -132,7 +132,7 @@ contract BeaconSystemTest is Test {
         amounts[1] = 3;
 
         vm.prank(address(factory));
-        ERC1155VaultImplementation(vault).mintBatch(user1, ids, amounts);
+        ERC1155VaultImplementation(vault).mintBatch(user1, ids, amounts, "");
 
         assertEq(ERC1155VaultImplementation(vault).balanceOf(user1, 1), 5);
         assertEq(ERC1155VaultImplementation(vault).balanceOf(user1, 2), 3);
@@ -169,7 +169,7 @@ contract BeaconSystemTest is Test {
         address vault1155 = factory.createERC1155Vault("https://test.uri/");
 
         vm.prank(address(factory));
-        ERC1155VaultImplementation(vault1155).mint(user1, 1, 5);
+        ERC1155VaultImplementation(vault1155).mint(user1, 1, 5, "");
 
         vm.prank(user1);
         ERC1155VaultImplementation(vault1155).burn(user1, 1, 2);
@@ -212,7 +212,7 @@ contract BeaconSystemTest is Test {
 
         // Mint tokens before upgrade
         vm.prank(address(factory));
-        ERC1155VaultImplementation(vault).mint(user1, 1, 5);
+        ERC1155VaultImplementation(vault).mint(user1, 1, 5, "");
 
         // Upgrade implementation (beacon owner is this contract)
         erc1155Beacon.upgrade(address(newImplementation));
@@ -225,7 +225,7 @@ contract BeaconSystemTest is Test {
 
         // Verify new minting still works
         vm.prank(address(factory));
-        ERC1155VaultImplementation(vault).mint(user2, 2, 3);
+        ERC1155VaultImplementation(vault).mint(user2, 2, 3, "");
         assertEq(ERC1155VaultImplementation(vault).balanceOf(user2, 2), 3);
     }
 
@@ -240,7 +240,7 @@ contract BeaconSystemTest is Test {
         address vault = factory.createERC1155Vault("https://test.uri/");
 
         vm.prank(user1); // Not the owner
-        ERC1155VaultImplementation(vault).mint(user1, 1, 5);
+        ERC1155VaultImplementation(vault).mint(user1, 1, 5, "");
     }
 
     receive() external payable {}
diff --git a/test/BeaconVault.t.sol b/test/BeaconVault.t.sol
index 3a8cd0d..65ae4cb 100644
--- a/test/BeaconVault.t.sol
+++ b/test/BeaconVault.t.sol
@@ -6,7 +6,7 @@ import "../src/beacon/VaultBeacon.sol";
 import "../src/beacon/VaultProxy.sol";
 import "../src/interfaces/IVaultBeacon.sol";
 import "../src/interfaces/IVaultProxy.sol";
-import "../src/interfaces/IERC165.sol";
+import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
 
 // Mock implementation for testing
 contract MockImplementation is IERC165 {
@@ -21,7 +21,7 @@ contract MockImplementation is IERC165 {
         initialized = true;
     }
 
-    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
+    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {
         return interfaceId == type(IERC165).interfaceId;
     }
 }
@@ -40,7 +40,7 @@ contract MockImplementationV2 is IERC165 {
         initialized = true;
     }
 
-    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
+    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {
         return interfaceId == type(IERC165).interfaceId;
     }
 }
diff --git a/test/DiamondVault.t.sol b/test/DiamondVault.t.sol
index cc50c7b..6087b68 100644
--- a/test/DiamondVault.t.sol
+++ b/test/DiamondVault.t.sol
@@ -59,7 +59,6 @@ contract DiamondVaultTest is Test {
     function setUp() public {
         // Derive witness address from private key
         witness = vm.addr(witnessPrivateKey);
-        console.log("Witness address:", witness);
 
         // Deploy mock contracts
         paymentToken = new MockERC20("Payment Token", "PAY");
